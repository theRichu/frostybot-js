// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © capissimo

//@version=5
strategy('Richu:LogisticRegression', 'RichuV3', overlay=true, margin_long=0, margin_short=0, currency='USD', initial_capital=1000, default_qty_type=strategy.percent_of_equity default_qty_value=90)

// Multi-timeframe Strategy based on Logistic Regression algorithm

// Description: 

// This strategy uses a classic machine learning algorithm that came from statistics -
// Logistic Regression (LR).

// The first and most important thing about logistic regression is that it is not a 
// 'Regression' but a 'Classification' algorithm. The name itself is somewhat misleading. 
// Regression gives a continuous numeric output but most of the time we need the output in 
// classes (i.e. categorical, discrete). For example, we want to classify emails into “spam” or 
// 'not spam',  classify treatment into “success” or 'failure', classify statement into “right” 
// or 'wrong', classify election data into 'fraudulent vote' or 'non-fraudulent vote', 
// classify market move into 'long' or 'short' and so on. These are the examples of 
// logistic regression having a binary output (also called dichotomous). 

// You can also think of logistic regression as a special case of linear regression when the 
// outcome variable is categorical, where we are using log of odds as dependent variable. 
// In simple words, it predicts the probability of occurrence of an event by fitting data to a 
// logit function.

// Basically, the theory behind Logistic Regression is very similar to the one from Linear 
// Regression, where we seek to draw a best-fitting line over data points, but in Logistic 
// Regression, we don’t directly fit a straight line to our data like in linear regression	. 
// Instead, we fit a S shaped curve, called Sigmoid, to our observations, that best 
// SEPARATES data points. Technically speaking, the main goal of building the model is to 
// find the parameters (weights) using gradient descent. 

// In this script the LR algorithm is retrained on each new bar trying to classify it 
// into one of the two categories. This is done via the logistic_regression function by
// updating the weights w in the loop that continues for iterations number of times.
// In the end the weights are passed through the sigmoid function, yielding a
// prediction.

// Mind that some assets require to modify the script's input parameters. For instance, 
// when used with BTCUSD and USDJPY, the 'Normalization Lookback' parameter should be set 
// down to 4 (2,...,5..), and optionally the 'Use Price Data for Signal Generation?' 
// parameter should be checked. The defaults were tested with EURUSD.

// Note: TradingViews's playback feature helps to see this strategy in action.
// Warning: Signals ARE repainting.

// Style tags: Trend Following, Trend Analysis
// Asset class: Equities, Futures, ETFs, Currencies and Commodities
// Dataset: FX Minutes/Hours++/Days

//-------------------- Inputs

ptype = input.string('Close', 'Price Type', options=['Open', 'High', 'Low', 'Close', 'HL2', 'OC2', 'OHL3', 'HLC3', 'OHLC4'])
reso = input.timeframe('', 'Resolution')

LuseSL = input.bool(true,  title="Use Stop Loss", group="LONG 🠕 PROFIT & LOSS")
LSLperc = input.float(title="Stop Loss (%)", defval=4.5, minval=0, maxval=50, step=.1, group="LONG 🠕 PROFIT & LOSS") / 100
SuseSL = input.bool(true,  title="Use Stop Loss", group="SHORT 🠗 PROFIT & LOSS")
SSLperc = input.float(title="Stop Loss (%)", defval=4.5, minval=0, maxval=50, step=.1, group="SHORT 🠗 PROFIT & LOSS") / 100

lookback = input.int(3, 'Lookback Window Size |2..n| (2)', minval=2)
nlbk = input.int(4, 'Normalization Lookback |2..240| (120)', minval=2, maxval=240)
lrate = input.float(0.0009, 'Learning Rate |0.0001..0.01|', minval=0.0001, maxval=0.01, step=0.0001)
iterations = input.int(1000, 'Training Iterations |50..20000|', minval=50)
ftype = input.string('Both', 'Filter Signals by', options=['Volatility', 'Volume', 'Both', 'None'])
curves = input(false, 'Show Loss & Prediction Curves?')
easteregg = input(true, 'Optional Calculation?')
useprice = input(true, 'Use Price Data for Signal Generation?')
// holding_p = input.int(1, 'Holding Period |1..n|', minval=1)


// TIME WINDOW ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
startYear = input.int(title="Start Year", defval=2022, minval=1800, maxval=2100, group="Date Limits")
startMonth = input.int(title="Start Month",defval=1, minval=1, maxval=12, group="Date Limits")
startDate = input.int(title="Start Date", defval=1, minval=1, maxval=31, group="Date Limits")
startHour = input.int(title="Start Hour", defval=0, minval=0, maxval=23, group="Date Limits")
startMinute = input.int(title="Start Minute", defval=0, minval=0, maxval=59, group="Date Limits")

endYear = input.int(title="End Year", defval=2025, minval=1800, maxval=2100, group="Date Limits")
endMonth = input.int(title="End Month", defval=7, minval=1, maxval=12, group="Date Limits")
endDate = input.int(title="End Date", defval=1, minval=1, maxval=31, group="Date Limits")

// Look if the close time of the current bar
// falls inside the date range

start = timestamp('Asia/Seoul', startYear, startMonth, startDate, startHour, startMinute)
end = timestamp('Asia/Seoul', endYear, endMonth, endDate, 0, 0)
isInRange() => (time >= start) and (time < end)

bgcolor(isInRange() ? color.new(color.yellow, 95) : na)

//-------------------- System Variables

var LONG = 1
var SHORT = -1
var HOLD = 0
var signal = HOLD
var hp_counter = 0

//-------------------- Custom Functions

volumeBreak(thres) =>
    rsivol = ta.rsi(volume, 14)
    osc = ta.hma(rsivol, 10)
    osc > thres

volatilityBreak(volmin, volmax) =>
    ta.atr(volmin) > ta.atr(volmax)

dot(v, w, p) =>  // dot product
    math.sum(v * w, p)

sigmoid(z) =>
    1.0 / (1.0 + math.exp(-z))

logistic_regression(X, Y, p, lr, iterations) => 
    w = 0.0, loss = 0.0
    for i=1 to iterations
        hypothesis = sigmoid(dot(X, 0.0, p))  //-- prediction
        loss := -1.0 / p * (dot(dot(Y, math.log(hypothesis) + (1.0 - Y), p), math.log(1.0 - hypothesis), p)) 
        gradient = 1.0 / p * (dot(X, hypothesis - Y, p))
        w := w - lr * gradient               //-- update weights
    
    [loss, sigmoid(dot(X, w, p))]            //-- current loss & prediction


minimax(ds, p, min, max) =>  // normalize to price
    hi = ta.highest(ds, p)
    lo = ta.lowest(ds, p)
    (max - min) * (ds - lo) / (hi - lo) + min

//-------------------- Logic

ds = ptype == 'Open' ? open : ptype == 'High' ? high : ptype == 'Low' ? low : ptype == 'Close' ? close : ptype == 'HL2' ? (high + low) / 2 : ptype == 'OC2' ? (open + close) / 2 : ptype == 'OHL3' ? (open + high + low) / 3 : ptype == 'HLC3' ? (high + low + close) / 3 : (open + high + low + close) / 4

base_ds = request.security('', reso, ds[barstate.ishistory ? 0 : 1])
synth_ds = math.log(math.abs(math.pow(base_ds, 2) - 1) + .5)  //-- generate a synthetic dataset

base = easteregg ? time : base_ds  //-- standard and optional calculation
synth = easteregg ? base_ds : synth_ds

[loss, prediction] = logistic_regression(base, synth, lookback, lrate, iterations)

scaled_loss = minimax(loss, nlbk, ta.lowest(base_ds, nlbk), ta.highest(base_ds, nlbk))
scaled_prediction = minimax(prediction, nlbk, ta.lowest(base_ds, nlbk), ta.highest(base_ds, nlbk))

filter = ftype == 'Volatility' ? volatilityBreak(1, 10) : ftype == 'Volume' ? volumeBreak(49) : ftype == 'Both' ? volatilityBreak(1, 10) and volumeBreak(49) : true

crossedUnder = ta.crossunder(scaled_loss, scaled_prediction)
crossedOver = ta.crossover(scaled_loss, scaled_prediction)

if(useprice)
    if( base_ds < scaled_loss and filter ) 
        signal := SHORT
    else if (base_ds > scaled_loss and filter)
        signal := LONG
    else 
        signal := nz(signal[1])
else 
    if (crossedUnder and filter)
	    signal :=  SHORT
    else if (crossedOver and filter)
	    signal :=  LONG	
    else
	    signal :=  nz(signal[1])

changed = ta.change(signal)

// if (changed)
//     hp_counter := 0
// else
//     hp_counter += 1
// hp_counter := changed ? 0 : hp_counter + 1

startLongTrade = changed and signal == LONG
startShortTrade = changed and signal == SHORT
endLongTrade=false
endShortTrade=false
// endLongTrade = signal == LONG and hp_counter == holding_p and not changed or changed and signal == SHORT
// endShortTrade = signal == SHORT and hp_counter == holding_p and not changed or changed and signal == LONG


//-------------------- Rendering

plot(curves ? scaled_loss : na, 'scaled_loss', color.new(color.blue, 0), 1)
plot(curves ? base_ds : na, 'base_ds', color.new(color.green, 0), 1)



// STOP LOSS▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
TradeDir=strategy.position_size>0?"LONG":strategy.position_size<0?"SHORT":na

//LONG STOP LOSS
LslconvertL = strategy.position_avg_price * (1 - LSLperc)
LSL = TradeDir == "LONG" and (math.min(open,close,low) < LslconvertL) and LuseSL 
//SHORT STOP LOSS
SslconvertS = strategy.position_avg_price * (1 + SSLperc)
SSL = TradeDir == "SHORT" and (math.max(open,close,high) > SslconvertS) and SuseSL 

stopLossLimit = TradeDir == "LONG"?LslconvertL:TradeDir=="SHORT"?SslconvertS:na
plot(stopLossLimit, color=color.new(TradeDir == "LONG" ? color.blue : color.red, 70), title="stopLossLimit", style=plot.style_stepline)
plot(strategy.position_avg_price, color=color.new(TradeDir == "LONG" ? color.blue : color.red, 10), title="positionPrice", style=plot.style_stepline, linewidth=1)

var nowDangerBox = box.new(na, na, na, na, border_color=na, xloc=xloc.bar_index)
moveDangerBox(_box) => 
    box.set_right(_box, bar_index)
    box.set_left(_box, strategy.opentrades.entry_bar_index(0))
    box.set_top(_box, math.max( strategy.position_avg_price, stopLossLimit))
    box.set_bottom(_box, math.min( strategy.position_avg_price, stopLossLimit))
    box.set_extend(_box, extend=extend.right)
    box.set_bgcolor(_box, color.new(color.red,90))

moveDangerBox(nowDangerBox)

//STRATEGY ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼

additional_cmd        = ",\"botType\":\"ANN\",\"basecurrency\":\"" + syminfo.basecurrency + "\"" + ",\"currency\":\"" + syminfo.currency + "\""

strategy.entry("Long", strategy.long, when=startLongTrade and isInRange(), alert_message=additional_cmd)
strategy.entry("Short", strategy.short, when=startShortTrade and isInRange(), alert_message=additional_cmd)


strategy.close("Long", comment="LSL",  when=LSL, alert_message=additional_cmd)
strategy.close("Short", comment="SSL",  when=SSL, alert_message=additional_cmd)
// strategy.close("Long", comment="EL",  when=endLongTrade)
// strategy.close("Short", comment="ES",  when=endShortTrade)

//ALERTS▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼

useentryalert  = input(defval=true, title="Use ENTRY Alert", group="Custom Alert Messages")
useexitalert   = input(defval=true, title="Use EXIT Alert", group="Custom Alert Messages")
usestopalert   = input(defval=true, title="Use STOP Alert", group="Custom Alert Messages")


// "market_position": "{{strategy.market_position}}", 
// "market_position_size": "{{strategy.market_position_size}}", 
// "position_size": "{{strategy.position_size}}",
// "action": "{{strategy.order.action}}",
// "contracts": "{{strategy.order.contracts}}",
// "price": "{{strategy.order.price}}"
marker
if (startLongTrade) and useentryalert
    alert(", \"market_position\":\"long\", \"action\":\"buy\""+ additional_cmd, alert.freq_once_per_bar)
if (startShortTrade) and useentryalert
    alert(", \"market_position\":\"short\", \"action\":\"sell\""+ additional_cmd, alert.freq_once_per_bar)
if LSL and usestopalert
    alert(", \"market_position\":\"flat\", \"action\":\"sell\""+stopstring, alert.freq_once_per_bar)
if SSL and usestopalert
    alert(", \"market_position\":\"flat\", \"action\":\"buy\""+stopstring, alert.freq_once_per_bar)
//END▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
////////////////////////////////////////////////////////////////////////////////
//-------------------- Backtesting (TODO)

lot_size = input.float(0.01, 'Lot Size', options=[0.01, 0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5, 10, 20, 30, 50, 100, 1000])

ohl3 = (open + high + low) / 3

var float start_long_trade = 0.
var float long_trades = 0.
var float start_short_trade = 0.
var float short_trades = 0.
var int wins = 0
var int trade_count = 0

if startLongTrade
    start_long_trade := ohl3
    start_long_trade
if endLongTrade
    trade_count := 1
    ldiff = ohl3 - start_long_trade
    wins := ldiff > 0 ? 1 : 0
    long_trades := ldiff * lot_size
    long_trades
if startShortTrade
    start_short_trade := ohl3
    start_short_trade
if endShortTrade
    trade_count := 1
    sdiff = start_short_trade - ohl3
    wins := sdiff > 0 ? 1 : 0
    short_trades := sdiff * lot_size
    short_trades

cumreturn = ta.cum(long_trades) + ta.cum(short_trades)  //-- cumulative return 
totaltrades = ta.cum(trade_count)
totalwins = ta.cum(wins)
totallosses = totaltrades - totalwins == 0 ? 1 : totaltrades - totalwins

//-------------------- Information

show_info = input(true, 'Show Info?')

var label lbl = na

tbase = (time - time[1]) / 1000
tcurr = (timenow - time_close[1]) / 1000

info = 'CR=' + str.tostring(cumreturn, '#.#') + '\nTrades: ' + str.tostring(totaltrades, '#') + '\nWin/Loss: ' + str.tostring(totalwins / totallosses, '#.##') + '\nWinrate: ' + str.tostring(totalwins / totaltrades, '#.#%') + '\nBar Time: ' + str.tostring(tcurr / tbase, '#.#%')

if show_info and barstate.islast
    lbl := label.new(bar_index, close, info, xloc.bar_index, yloc.price, color.new(color.blue, 100), label.style_label_left, color.black, size.small, text.align_left)
    label.delete(lbl[1])


